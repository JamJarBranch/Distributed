# 生成器

## 可迭代对象

可迭代对象不是迭代器，也不是生成器

是否可以迭代：

1. `dir()`方法查看`__iter__`说明是可迭代的
2. 当没有`__iter__`时， Python 解释器会去找`__getitem__`，尝试按顺序（从索引0开始）获取元素，不抛异常，即是可迭代

判断：通过 `for循环`或者`iter()` 去真实运行

## 迭代器

**迭代器**，是在可迭代的基础上，加了一个next()方法

要创建一个迭代器，我们首先，得有一个可迭代对象

1. 迭代器，是其内部实现了，`__next__` 这个魔术方法。(Python3.x)
2. 可以通过，`dir()`方法来查看是否有`__next__`来判断一个变量是否是迭代器的。

## 生成器

**生成器**，是在迭代器的基础上实现了`yield`。

引入生成器是为了实现一个在计算下一个值时不需要浪费空间的结构

### 创建列表生成器

```
# 使用列表生成式，注意不是[]，而是()
L = (x * x for x in range(10))
print(isinstance(L, Generator))  # True
```

### yield

相当于我们函数里的return。

在每次next()，或者for遍历的时候，都会yield这里将新的值返回回去，并在这里阻塞，等待下一次的调用。

实现节省内存，实现异步编程。

可迭代对象和迭代器，是将所有的值都生成存放在内存中，而`生成器`则是需要元素才临时生成，节省时间，节省空间。

### 运行/激活

生成器并不是一次生成所有元素，而是一次一次的执行返回

激活主要有两个方法 

- 使用`next()` 
- 使用`generator.send(None)`

### 执行状态

> `GEN_CREATED` # 等待开始执行 
>
> `GEN_RUNNING` # 解释器正在执行（只有在多线程应用中才能看到这个状态） 
>
> `GEN_SUSPENDED` # 在yield表达式处暂停 
>
> `GEN_CLOSED` # 执行结束

### 异常处理

生成器工作过程中，若生成器不满足生成元素的条件，就`会`/`应该` 抛出异常（`StopIteration`）

列表生成式构建的生成器，其内部已经自动帮我们实现了抛出异常这一步

我们在自定义一个生成器的时候，我们也应该在不满足生成元素条件的时候，抛出异常

# 协程的yield from

`yield from` 后面需要加的是可迭代对象，它可以是普通的可迭代对象，也可以是迭代器，甚至是生成器

**生成器的嵌套**

`yield from` 后面加上一个生成器后，就实现了生成器的嵌套

实现生成器的嵌套，并不是一定必须要使用`yield from`，而是使用`yield from`可以让我们避免让我们自己处理各种料想不到的异常，而让我们专注于业务代码的实现

**功能** : 处理异常



